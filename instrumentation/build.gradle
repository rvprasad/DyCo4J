plugins {
    id 'java'
    id 'jacoco'
    id 'groovy'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

repositories {
    mavenCentral()
    flatDir dirs: ['../utility/build/libs/', '../logging/build/libs/']
}

// In this section you declare the dependencies for your production and test code
dependencies {
    implementation 'org.ow2.asm:asm:6.2.1'
    implementation 'org.ow2.asm:asm-commons:6.2.1'
    implementation 'org.ow2.asm:asm-tree:6.2.1'
    implementation 'commons-cli:commons-cli:1.3.1'
    implementation 'org.slf4j:slf4j-api:1.7.22'
    implementation ":dyco4j-logging:$DYCO4J_LOGGING_VERSION"
    implementation ":dyco4j-utility:$DYCO4J_UTILITY_VERSION"
    runtimeOnly 'com.google.code.gson:gson:2.8.0'

    testImplementation 'org.slf4j:slf4j-simple:1.7.22'
    testImplementation 'com.google.code.gson:gson:2.8.0'
    testImplementation 'org.codehaus.groovy:groovy-all:2.4.7'
    testImplementation 'junit:junit:4.12'
}

compileJava {
    sourceCompatibility = 11
    targetCompatibility = 11
    options.compilerArgs << '-Xlint'
}

compileTestJava {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
    options.compilerArgs << '-Xlint'
}

tasks.register('copyLibs', Copy) {
    into layout.buildDirectory.dir('libs')
    from configurations.runtimeClasspath
}

test {
    systemProperty 'logging.jar', configurations.runtimeClasspath.files { it ==~ /.*dyco4j-logging.*/ }[0]
    exclude '**/*TestSubject.class'
}

tasks.register('entryJar', Jar) {
    dependsOn copyLibs, test
    archiveBaseName = 'dyco4j'
    archiveAppendix = 'entry'
    archiveClassifier = 'cli'
    from sourceSets.main.output
    exclude '**/internals/**'
    manifest {
        attributes (
            'Main-Class': 'dyco4j/instrumentation/entry/CLI',
            'Class-Path': configurations.runtimeClasspath.collect { it.getName() }.join(' ')
        )
    }
}

tasks.register('internalsJar', Jar) {
    dependsOn copyLibs, test
    archiveBaseName = 'dyco4j'
    archiveAppendix = 'internals'
    archiveClassifier = 'cli'
    from sourceSets.main.output
    exclude '**/entry/**'
    manifest {
        attributes(
            'Main-Class': 'dyco4j/instrumentation/internals/CLI',
            'Class-Path': configurations.runtimeClasspath.collect { it.getName() }.join(' ')
        )
    }
}

jar {
    dependsOn entryJar, internalsJar
}

tasks.register('entryFatJar', Jar) {
    manifest.from entryJar.manifest
    archiveBaseName = 'dyco4j'
    archiveAppendix = 'entry'
    archiveClassifier = 'all'
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    from {
        configurations.testRuntimeClasspath.filter { it ==~ ".*slf4j.*" }.collect { it.isDirectory() ? it : zipTree(it) }
    }
    exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
    setDuplicatesStrategy('exclude')
    with entryJar
}

tasks.register('internalsFatJar', Jar) {
    manifest.from internalsJar.manifest
    archiveBaseName = 'dyco4j'
    archiveAppendix = 'internals'
    archiveClassifier = 'all'
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    from {
        configurations.testRuntimeClasspath.filter { it ==~ ".*slf4j.*" }.collect { it.isDirectory() ? it : zipTree(it) }
    }
    exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
    setDuplicatesStrategy('exclude')
    with internalsJar
}

tasks.register('fatJars', Jar) {
    dependsOn entryFatJar, internalsFatJar
}

artifacts {
    archives entryJar
    archives internalsJar
}

jacocoTestReport {
    reports {
        xml.required = false
        csv.required = false
    }
}

version = '1.0.0'

