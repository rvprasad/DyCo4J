plugins {
    id 'java'
    id 'jacoco'
    id 'groovy'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    mavenCentral()
    flatDir dirs: ['../utility/build/libs/', '../logging/build/libs/']
}

// In this section you declare the dependencies for your production and test code
dependencies {
    implementation 'org.ow2.asm:asm:9.6'
    implementation 'org.ow2.asm:asm-commons:9.6'
    implementation 'org.ow2.asm:asm-tree:9.6'
    implementation 'commons-cli:commons-cli:1.6.0'
    implementation 'org.slf4j:slf4j-api:2.0.12'
    implementation ":dyco4j-logging:$DYCO4J_LOGGING_VERSION"
    implementation ":dyco4j-utility:$DYCO4J_UTILITY_VERSION"
    runtimeOnly 'com.google.code.gson:gson:2.10.1'

    testImplementation 'org.slf4j:slf4j-simple:2.0.12'
    testImplementation 'com.google.code.gson:gson:2.10.1'
    testImplementation 'org.apache.groovy:groovy-all:4.0.18'
    testImplementation 'org.apache.groovy:groovy-dateutil:4.0.18'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.2'
}

compileJava {
    sourceCompatibility = 21
    targetCompatibility = 21
    options.compilerArgs << '-Xlint'
}

compileTestJava {
    sourceCompatibility = 1.9
    targetCompatibility = 1.9
    options.compilerArgs << '-Xlint'
}

tasks.register('copyLibs', Copy) {
    into layout.buildDirectory.dir('libs')
    from configurations.runtimeClasspath
}

test {
    systemProperty 'logging.jar', configurations.runtimeClasspath.files { it ==~ /.*dyco4j-logging.*/ }[0]
    exclude '**/*TestSubject.class'
}

tasks.register('entryJar', Jar) {
    dependsOn copyLibs, test
    archiveBaseName = 'dyco4j'
    archiveAppendix = 'entry'
    archiveClassifier = 'cli'
    from sourceSets.main.output
    exclude '**/internals/**'
    manifest {
        attributes (
            'Main-Class': 'dyco4j/instrumentation/entry/CLI',
            'Class-Path': configurations.runtimeClasspath.collect { it.getName() }.join(' ')
        )
    }
}

tasks.register('internalsJar', Jar) {
    dependsOn copyLibs, test
    archiveBaseName = 'dyco4j'
    archiveAppendix = 'internals'
    archiveClassifier = 'cli'
    from sourceSets.main.output
    exclude '**/entry/**'
    manifest {
        attributes(
            'Main-Class': 'dyco4j/instrumentation/internals/CLI',
            'Class-Path': configurations.runtimeClasspath.collect { it.getName() }.join(' ')
        )
    }
}

jar {
    dependsOn entryJar, internalsJar
}

tasks.register('entryFatJar', Jar) {
    manifest.from entryJar.manifest
    archiveBaseName = 'dyco4j'
    archiveAppendix = 'entry'
    archiveClassifier = 'all'
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    from {
        configurations.testRuntimeClasspath.filter { it ==~ ".*slf4j.*" }.collect { it.isDirectory() ? it : zipTree(it) }
    }
    exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
    setDuplicatesStrategy('exclude')
    with entryJar
}

tasks.register('internalsFatJar', Jar) {
    manifest.from internalsJar.manifest
    archiveBaseName = 'dyco4j'
    archiveAppendix = 'internals'
    archiveClassifier = 'all'
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    from {
        configurations.testRuntimeClasspath.filter { it ==~ ".*slf4j.*" }.collect { it.isDirectory() ? it : zipTree(it) }
    }
    exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
    setDuplicatesStrategy('exclude')
    with internalsJar
}

tasks.register('fatJars', Jar) {
    dependsOn entryFatJar, internalsFatJar
}

artifacts {
    archives entryJar
    archives internalsJar
}

test {
    useJUnitPlatform {
        includeEngines 'junit-jupiter'
    }
}

jacocoTestReport {
    reports {
        xml.required = false
        csv.required = false
    }
}

version = '1.0.0'

